<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>图形化编程中的&#34;帽子&#34;积木 - 夜行人</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="种瓜" /><meta name="description" content="前言 提醒: Snap! 最新版本支持自定义&amp;quot;帽子&amp;quot;积木! 案例演示 标题中的图形化编程是指: Scratch Snap! MicroBlocks GP &amp;ldquo;帽子&amp;quot;积木 Scratch" /><meta name="keywords" content="education, programming, Technology" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="http://wwj718.github.io/post/%E7%BC%96%E7%A8%8B/hat-blocks/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.69e0bbe2419d9b0efbdcc1d3b4338bba03a6f6789ae2832bc1af58e5b2757470.css" rel="stylesheet">
<link rel="stylesheet" href="/post/img/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="图形化编程中的&#34;帽子&#34;积木" />
<meta property="og:description" content="前言 提醒: Snap! 最新版本支持自定义&quot;帽子&quot;积木! 案例演示 标题中的图形化编程是指: Scratch Snap! MicroBlocks GP &ldquo;帽子&quot;积木 Scratch" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://wwj718.github.io/post/%E7%BC%96%E7%A8%8B/hat-blocks/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-01-03T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-01-03T00:00:00+00:00" />

<meta itemprop="name" content="图形化编程中的&#34;帽子&#34;积木">
<meta itemprop="description" content="前言 提醒: Snap! 最新版本支持自定义&quot;帽子&quot;积木! 案例演示 标题中的图形化编程是指: Scratch Snap! MicroBlocks GP &ldquo;帽子&quot;积木 Scratch"><meta itemprop="datePublished" content="2024-01-03T00:00:00+00:00" />
<meta itemprop="dateModified" content="2024-01-03T00:00:00+00:00" />
<meta itemprop="wordCount" content="3650">
<meta itemprop="keywords" content="MicroBlocks,Scratch," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="图形化编程中的&#34;帽子&#34;积木"/>
<meta name="twitter:description" content="前言 提醒: Snap! 最新版本支持自定义&quot;帽子&quot;积木! 案例演示 标题中的图形化编程是指: Scratch Snap! MicroBlocks GP &ldquo;帽子&quot;积木 Scratch"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">夜行人</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/post/%E9%9A%8F%E7%AC%94/aboutme/">
        <li class="mobile-menu-item">About-Me</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">夜行人</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/%E9%9A%8F%E7%AC%94/aboutme/">About-Me</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">图形化编程中的&#34;帽子&#34;积木</h1>

      <div class="post-meta">
        <span class="post-time"> 2024-01-03 </span>
        <div class="post-category">
            <a href="/categories/%E7%BC%96%E7%A8%8B/"> 编程 </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#前言">前言</a></li>
        <li><a href="#帽子积木">&ldquo;帽子&quot;积木</a>
          <ul>
            <li><a href="#scratch">Scratch</a></li>
            <li><a href="#snap--microblocks--gp">Snap! / MicroBlocks / GP</a></li>
          </ul>
        </li>
        <li><a href="#移植-scratch-的帽子积木">移植 Scratch 的&quot;帽子&quot;积木</a>
          <ul>
            <li><a href="#microbit-插件">micro:bit 插件</a>
              <ul>
                <li><a href="#移植到-snap-中">移植到 Snap! 中</a></li>
              </ul>
            </li>
            <li><a href="#microbit-more-插件">micro:bit more 插件</a>
              <ul>
                <li><a href="#移植到-snap-中-1">移植到 Snap! 中</a></li>
              </ul>
            </li>
            <li><a href="#更多">更多</a></li>
          </ul>
        </li>
        <li><a href="#思考">思考</a>
          <ul>
            <li><a href="#microblocks-中的情形">MicroBlocks 中的情形</a></li>
          </ul>
        </li>
        <li><a href="#参考">参考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="前言">前言</h2>
<p><strong>提醒: Snap! 最新版本支持自定义&quot;帽子&quot;积木! <a href="https://x.com/moenig/status/1858860219914145960">案例演示</a></strong></p>
<p>标题中的图形化编程是指:</p>
<ul>
<li>Scratch</li>
<li>Snap!</li>
<li>MicroBlocks</li>
<li>GP</li>
</ul>
<h2 id="帽子积木">&ldquo;帽子&quot;积木</h2>
<h3 id="scratch">Scratch</h3>
<p>在 Scratch 中, 有许多 &ldquo;帽子&rdquo;(Hat) 积木, 它们看起来像一顶帽子。</p>
<img width=800 src="/post/img/hat-blocks-01.png" />
<p>图中的黄色积木都来自 &ldquo;事件&rdquo; 分类, &ldquo;帽子&rdquo; 积木通常用于响应事件: 当某个事件发生时, 就运行帽子底下的积木。</p>
<p>图中的绿色积木来自插件, 开发者可以创建自定义的&quot;帽子&rdquo; 积木。</p>
<h3 id="snap--microblocks--gp">Snap! / MicroBlocks / GP</h3>
<p>Snap! / MicroBlocks / GP 内置了一些&quot;帽子&quot;积木:</p>
<img width=800 src="/post/img/hat-blocks-02.png" />
<p>但它们仨都不允许用户自定义&quot;帽子&quot;积木。 而是提供了一个通用的&quot;帽子&quot;积木: <code>当(when)</code></p>
<img width=800 src="/post/img/hat-blocks-03.png" />
<p><code>当(when)</code> 积木的功能是: 接受某个有返回值(true/false)的积木(椭圆(reporter)或者六边形(predicate))作为参数, 当返回值为 true 时, 则运行其下的积木。</p>
<p>Snap! / MicroBlocks / GP 的洞察是: <code>hat = when + reporter</code>。</p>
<h2 id="移植-scratch-的帽子积木">移植 Scratch 的&quot;帽子&quot;积木</h2>
<p>当我们打算将 Scratch 插件迁移为 Snap! 插件时, 会遇到这样的问题: 怎么迁移&quot;帽子&quot;积木?</p>
<p>让我们来考察两个 Scratch 插件:</p>
<ul>
<li><a href="https://github.com/scratchfoundation/scratch-vm/blob/develop/src/extensions/scratch3_microbit/index.js">micro:bit 插件</a></li>
<li><a href="https://github.com/microbit-more/mbit-more-v2">micro:bit more 插件</a></li>
</ul>
<h3 id="microbit-插件">micro:bit 插件</h3>
<p>先考察下 micro:bit 插件的这个&quot;帽子&quot;积木: <code>当按下 A 按钮</code></p>
<img width=400 src="/post/img/hat-blocks-04.png" />
<p>这个积木的功能是: 当 micro:bit 上的 A 按钮被按下时, 触发这个积木。</p>
<p>我们首先将碰到这个问题: 如何知道 <code>A 按钮被按下</code> ?</p>
<p>micro:bit 插件作者的想法是, 在 micro:bit 里持续运行一段程序(<a href="https://downloads.scratch.mit.edu/microbit/scratch-microbit.hex.zip">固件</a>), 这段程序不停地观察 micro:bit 的状态(如 A 按键是否被按下), 并把这些状态以每秒几十次的频率传递给 Scratch。至于传递的方式, 可能通过 usb 串口也可能通过 BLE(蓝牙) 。 <code>以一定的频率不断发送 micro:bit 自身状态</code> 的想法受到 <a href="https://s4a.cat/">S4A</a> 的影响。</p>
<p>在 Scratch 一边, 不断地收到 micro:bit 发来的状态数据, 不停地观察(在一个持续运行的循环中)这些数据中表示按钮的位置, 如果这个数据表明按下, 则运行<code>当按下 A 按钮</code>帽子下的积木(执行它的语义功能)。以下是它的具体实现:</p>
<p>接收来自 micro:bit 的状态数据(<a href="https://github.com/scratchfoundation/scratch-vm/blob/v2.1.50/src/extensions/scratch3_microbit/index.js#L324C1-L348C6">_onMessage</a>):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">    <span class="nx">_onMessage</span> <span class="p">(</span><span class="nx">base64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// parse data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">Base64Util</span><span class="p">.</span><span class="nx">base64ToUint8Array</span><span class="p">(</span><span class="nx">base64</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">tiltX</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">tiltX</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">))</span> <span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">tiltX</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">tiltY</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">tiltY</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">))</span> <span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">tiltY</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">buttonA</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">buttonB</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">touchPins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">touchPins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">touchPins</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">_sensors</span><span class="p">.</span><span class="nx">gestureState</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// cancel disconnect timeout and start a new one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nb">window</span><span class="p">.</span><span class="nx">clearTimeout</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_timeoutID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">_timeoutID</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">_ble</span><span class="p">.</span><span class="nx">handleDisconnectError</span><span class="p">(</span><span class="nx">BLEDataStoppedError</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="nx">BLETimeout</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>当按下 A 按钮</code> 具体的实现代码(<a href="https://github.com/scratchfoundation/scratch-vm/blob/v2.1.50/src/extensions/scratch3_microbit/index.js#L793">whenButtonPressed</a>):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">    <span class="nx">whenButtonPressed</span> <span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">BTN</span> <span class="o">===</span> <span class="s1">&#39;any&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_peripheral</span><span class="p">.</span><span class="nx">buttonA</span> <span class="o">|</span> <span class="k">this</span><span class="p">.</span><span class="nx">_peripheral</span><span class="p">.</span><span class="nx">buttonB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">BTN</span> <span class="o">===</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_peripheral</span><span class="p">.</span><span class="nx">buttonA</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">BTN</span> <span class="o">===</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_peripheral</span><span class="p">.</span><span class="nx">buttonB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>值得注意的是, <code>_onMessage</code> 和 <code>whenButtonPressed</code> 是两个独立的线程, 前者会不断写入(更新) buttonA 的状态, 后者则不断读取 buttonA 的状态。</p>
<p><code>_onMessage</code> 中的状态消息是源源不断的, buttonA 变量相当于一个暂存它的槽( <strong>只存一个最近的状态</strong> )。而 whenButtonPressed 每次只能读到 <strong>最近一次存到槽里的数据</strong> 。</p>
<h4 id="移植到-snap-中">移植到 Snap! 中</h4>
<p>一旦弄懂这些, 将 <code>当按下 A 按钮</code> 移植到 Snap! 中就不难了。</p>
<p>我们可以复用 <a href="https://downloads.scratch.mit.edu/microbit/scratch-microbit.hex.zip">micro:bit 的固件</a>, 因为从前头的分析得知 micro:bit 的固件负责源源不断往外发送 micro:bit 的状态, 至于发给谁它并不关心, 既然可以发到 Scratch, 当然也可以发到 Snap! 也行。</p>
<p>以下是 Snap! 中实现 <code>当按下 A 按钮</code> 的相关代码:</p>
<p><img src="/post/img/hat-blocks-05.png" alt=""></p>
<p><img src="/post/img/hat-blocks-06.png" alt=""></p>
<p>有以下几点值得注意:</p>
<ol>
<li>Snap! 通过 BLE(蓝牙) 连接 micro:bit, 通过订阅 BLE 广播来接收 micro:bit 持续发出的状态信息。</li>
<li>将收到的状态信息存放到变量 <code>mb_notify_datas</code> 里, 相当于 Scratch 中存储最新消息的变量, 只存下 <strong>最近的一条状态信息</strong> 。</li>
<li><strong>查看 A 按钮状态</strong> 被实现为 predicate 积木(六边形, 我将它视为一种返回布尔值的 reporter), 通过与 <code>当when</code> 积木的组合，而得到&quot;帽子&quot;积木。</li>
<li>一切都在 Snap! 里实现!</li>
</ol>
<h3 id="microbit-more-插件">micro:bit more 插件</h3>
<p>Scratch 扩展插件中的&quot;帽子&quot;积木, 采用的都是&quot;状态流&quot;的风格, 外部设备源源不断地传递&quot;状态流&quot;到 Scratch 里(受到 S4A 的影响)。</p>
<p>有一类信息天生适合使用&quot;状态流&quot;来传递, 诸如陀螺仪的数据。</p>
<p>但许多情况下，要传递外部设备或系统的信息，采用事件是更好的选择。诸如将 MQTT 引入图形化编程系统。</p>
<p>让我们分别采用&quot;状态流&quot;和事件两种视角来看待 <code>当按下 A 按钮</code> 。</p>
<ol>
<li>状态流: 这种视角下, micro:bit 源源不断地报告 A 按钮的状态: <code>true false false false false true false</code></li>
<li>事件: 这种视角下， micro:bit 只在上述情况中(<code>true false false false false true false</code>)两次状态为 true 的时候, 各发布一个事件, 其余情况保持沉默(沉默表示 false)。这种方式显然更加高效。</li>
</ol>
<p><a href="https://github.com/microbit-more/mbit-more-v2">micro:bit more 插件</a> 正是采用了事件的风格。</p>
<p>让我们看看基于事件的 <code>当按下 A 按钮</code> 的实现（<a href="https://github.com/microbit-more/mbit-more-v2/blob/0.2.5/src/vm/extensions/block/index.js#L2753">whenButtonEvent</a>):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">    <span class="nx">whenButtonEvent</span> <span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">updateLastButtonEventTimer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="p">.</span><span class="nx">updateLastButtonEventTimer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">updatePrevButtonEvents</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">updateLastButtonEventTimer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">},</span> <span class="k">this</span><span class="p">.</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">currentStepTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">buttonName</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">NAME</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">eventName</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">EVENT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">lastTimestamp</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="p">.</span><span class="nx">_peripheral</span><span class="p">.</span><span class="nx">getButtonEventTimestamp</span><span class="p">(</span><span class="nx">buttonName</span><span class="p">,</span> <span class="nx">eventName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">lastTimestamp</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">prevButtonEvents</span><span class="p">[</span><span class="nx">buttonName</span><span class="p">])</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">lastTimestamp</span> <span class="o">!==</span> <span class="k">this</span><span class="p">.</span><span class="nx">prevButtonEvents</span><span class="p">[</span><span class="nx">buttonName</span><span class="p">][</span><span class="nx">eventName</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里有 2 点值得注意:</p>
<ol>
<li>lastTimestamp 的使用。前边说过帽子积木(<code>whenButtonEvent</code>)在一个循环里持续不断地运行, 进来的事件会存放在一个变量(槽)里, whenButtonEvent 需要知道槽里的事件是否之前被访问过。有很多方式可以做到这点, 方案 1 是为事件添加一个时间戳(这种方式通常是最佳选择), 并且给 whenButtonEvent 分配一个变量记住最近一个事件的时间。 方案 2 是在每次访问事件(槽)之后, 清空它(<a href="https://github.com/CodeLabClub/scratch3_eim">EIM 插件</a> 使用了这个技巧) 。</li>
<li>由于帽子积木(<code>whenButtonEvent</code>)在一个循环里持续不断地运行, 这导致任何有状态的变量需要存储在 <code>this</code> 里。</li>
</ol>
<h4 id="移植到-snap-中-1">移植到 Snap! 中</h4>
<p>实际上, 我并没有将 micro:bit more 插件移植到 Snap!(因为我们有更强大和通用的 MicroBlocks 插件), 但要这么做是很简单的。</p>
<p>在 Snap! 中对事件以及 lastTimestamp 的处理非常容易, 我们通过以下的示例来说明:</p>
<p><img src="/post/img/hat-blocks-07.png" alt=""></p>
<p>值得注意的是这里的 lastTimestamp 是 <strong>块变量</strong> , <strong>块变量</strong> 在积木多次运行过程中保持自身的状态, 类似于前边 Scratch whenButtonEvent 函数中与 <code>this</code> 有关的变量。</p>
<p>设置 <code>buttonAEvent</code> 模拟了事件流入 Snap! 的过程。在真实的情况中, 事件可能是通过 usb 串口、BLE 广播(如前边 BLE 广播的例子) 或者经过网络(如 MQTT, WebSocket)进入 Snap! 的。 值得注意的是, buttonAEvent 使用一个列表存储消息, 列表的第 2 个元素是我们收到消息时的时间戳。这个时间戳究竟是事件本身携带的, 还是 Snap! 收到消息时添加的，并不重要。</p>
<p>点击尝试 <a href="https://codelabclub.github.io/Snap/snap.html#open:https://wwj718.github.io/post/img/whenButtonAEvent.xml">whenButtonAEvent</a>。</p>
<!--
https://codelabclub.github.io/Snap/snap.html#run:https://wwj718.github.io/post/img/whenButtonAEvent.xml
https://snap.berkeley.edu/snap/snap.html#present:Username=birdbraintech&ProjectName=MicrobitStarterProject&editMode&noRun
-->
<h3 id="更多">更多</h3>
<p>当我将 EIM 插件从 Scratch 迁移到 Snap! 时, 我将基于清空事件(槽)的机制改为基于事件时间戳的机制。</p>
<p>这是<a href="https://github.com/CodeLabClub/scratch3_eim/blob/v3/index.js#L204">之前 Scratch 的机制</a>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">    <span class="nx">isTargetTopicMessage</span><span class="p">(</span><span class="nx">targerNodeId</span><span class="p">,</span> <span class="nx">targetContent</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="nx">targetContent</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">adapter_node_content_hat</span> <span class="o">||</span> <span class="nx">targetContent</span> <span class="o">===</span> <span class="s2">&#34;_any&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="nx">targerNodeId</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">node_id</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">adapter_node_content_hat</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 每次清空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">this</span><span class="p">.</span><span class="nx">node_id</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">},</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//1ms,  todo: 改为 this.runtime.currentStepTime
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是目前 Snap! 的机制:</p>
<p><img src="/post/img/hat-blocks-08.png" alt=""></p>
<h2 id="思考">思考</h2>
<p>我们在前边遇到的问题, 可以采用 <strong>缓冲区(buffer)</strong> 视角看待它(<a href="(%3Chttps://en.wikipedia.org/wiki/Stream_(computing)">流(Stream)</a>&gt;)也是看待这个问题的一个有趣视角)。 我们将来自 micro:bit 的事件或状态流存储在 Scratch 或 Snap!的一个变量(buffer)里, 然后在 帽子/predicate 积木中根据 buffer 里的数据给出判断(A 按钮是否按下)。</p>
<blockquote>
<p>在计算机科学中，数据缓冲区（或简称缓冲区(buffer)）是用于临时存储数据的内存区域，当数据从一个地方移动到另一个地方时会使用 &ndash;<a href="https://en.wikipedia.org/wiki/Data_buffer">wiki: Data buffer</a></p>
</blockquote>
<p>由于我们识别到了问题, 得到了关键词: buffer, 把这把钥匙塞到 Google 的钥匙孔里, 就可以打开许多扇门, 里头尽是计算机领域长期积累的经验。</p>
<p>在典型的 Scratch/Snap! 插件中, 要处理来自外部系统的输入数据, 使用单一变量作为缓冲区就足够了, 因为 Scratch/Snap! 处理数据的速度比外部系统传入数据的速度更快。</p>
<p>缓冲区更典型的用途是, 在某些时间里, 进入系统的数据快过消耗它的速度。 此时需要构建更为复杂的缓冲区, 诸如<a href="https://en.wikipedia.org/wiki/Circular_buffer">环形缓冲区</a>, John Maloney 在 MicroBlocks 使用了 <a href="https://bitbucket.org/john_maloney/smallvm/src/f468d6f375f25985123972812c025befbf551b5c/vm/runtime.c?at=master#lines-488">环形缓冲区</a> 来处理消息广播。</p>
<h3 id="microblocks-中的情形">MicroBlocks 中的情形</h3>
<p>这篇文章讨论 Scratch 和 Snap! 居多, 讨论 MicroBlocks 的部分很少。 原因之一是我最近的工作涉及将插件从 Scratch 迁移到 Snap! ; 原因之二是 MicroBlocks 在这方面的设计与 Snap! 很相似。</p>
<p>前边提到:</p>
<blockquote>
<p>whenButtonEvent 需要知道槽里的事件是否之前被访问过。有很多方式可以做到这点, 方案 1 是为事件添加一个时间戳(这种方式通常是最佳选择), 并且给 whenButtonEvent 分配一个变量记住最近一个事件的时间。 方案 2 是在每次访问事件(槽)之后, 清空它</p>
</blockquote>
<p>MicroBlocks 在涉及 buffer 的情况下(诸如处理网络消息)，也需要处理这个问题, 但 MicroBlocks 选择了不同的方案。</p>
<p>在 MicroBlocks 存在两种风格处理这个问题:</p>
<p>其一以 wifi 广播库(以及 micro:bit radio 库)为代表:</p>
<p><img src="/post/img/hat-blocks-09.png" alt=""></p>
<p>这种风格里, 使用一个变量(<code>wifi广播消息已收到?</code>)标记 buffer 的消息是否已经读取过, 使用另一个变量(<code>wifi最后的数字</code>)存储最后收到的wifi广播消息, 即使最近只收到一条消息，多次点击这个积木，每次都会返回最后一条消息。</p>
<p>我们可以使用 <code>当(when)</code> 来重写上图的代码:</p>
<p><img src="/post/img/hat-blocks-11.png" alt=""></p>
<p>其二以 UDP 库为代表:</p>
<p><img src="/post/img/hat-blocks-10.png" alt=""></p>
<p>这种风格里, 只使用一个变量: <code>UDP 接受数据包</code>, 如果最近只收到一条消息, 第一次运行这个积木, 将返回这条消息, 再次运行返回 <code>false</code>。 这种风格类似我们之前提到的方案 2:</p>
<blockquote>
<p>方案 2 是在每次访问事件(槽)之后, 清空它</p>
</blockquote>
<p>这种风格的积木，无法与 <code>当(when)</code> 配合使用。</p>
<p>从上边的例子可以看到，无论哪种处理方式，都只是摆弄不同的变量而已，buffer 也只是变量。 变量(memory)在计算(computing)中如此重要有其深刻原因。变量(memory) 几乎是计算(computing)中最重要的两个要素之一，另一个要素是移动读写头，它们共同构成图灵机，摆弄变量(memory) 相当于读写图灵机的纸带。</p>
<!--
消耗型的积木

底层编程大多数都只是在摆弄某一个内存区域的数据，MicroBlocks的活性(liveness)让这件事变得非常简单而可理解

## FAQ

### 按键帽子积木不需要点击绿旗就可以响应事件。当积木需要点击运行才开始监听。这是如何实现的呢？

绿旗和按键帽子积木

MicroBlocks 中需要，Snap 不需要
-->
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/scratchfoundation/scratch-vm/blob/develop/src/extensions/scratch3_microbit/index.js">micro:bit 插件</a></li>
<li><a href="https://github.com/microbit-more/mbit-more-v2">micro:bit more 插件</a></li>
<li><a href="https://github.com/CodeLabClub/scratch3_eim">scratch3_eim</a></li>
<li><a href="https://en.wikipedia.org/wiki/Data_buffer">Data buffer</a>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Circular_buffer">Circular buffer</a></li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Stream_(computing)">Stream_(computing)</a></li>
<li><a href="https://chat.openai.com/share/60725895-b308-417f-8cbc-0bb9a95ff491">ChatGPT: 图灵机的要素是什么</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">种瓜</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2024-01-03
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/microblocks/">MicroBlocks</a>
          <a href="/tags/scratch/">Scratch</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E7%BC%96%E7%A8%8B/what-is-alan-kays-alternative-solution-for-the-web-which-he-mentioned-in-oopsla-97/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">[译]Alan Kay 在 OOPSLA&#39;97 中提到的 Web 的替代解决方案是什么？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E7%BC%96%E7%A8%8B/microblocks-teachable-machine/">
            <span class="next-text nav-default">MicroBlocks ❤️ Teachable Machine</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:wuwenjie718@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="mailto:wuwenjie718@gmail.com" class="iconfont icon-out-me" title="out-me"></a>
      <a href="https://github.com/wwj718" class="iconfont icon-github" title="github"></a>
  <a href="http://wwj718.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  
  <span><a target="_blank" href="https://cn.bing.com/search?q=site%3Awwj718.github.io%20%20codelab-adapter">搜索本站</a></span>
  <span class="division">|</span>
  <span><a target="_blank" href="/index.xml">RSS订阅</a></span>
  <span class="division">|</span>
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2013 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span><span>种瓜</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="/post/img/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="/post/img/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="/post/img/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?18db4b662c04fbd6cc2851d246c51b3f";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>
