module main
author unknown
version 1 0 
description ''

  spec ' ' 'favIconRequest' 'favIconRequest'
  spec ' ' 'formRequest' 'formRequest _' 'auto' '10'
  spec ' ' 'homePageRequest' 'homePageRequest'
  spec ' ' 'rgbFormRequest' 'rgbFormRequest _' 'auto' '10'

to favIconRequest {
  local 'favIconHTML' '<html><head><link rel="icon" href="data:,"></head></html>'
  '[net:respondToHttpRequest]' '200 OK' favIconHTML
}

to formRequest path {
  comment 'Show that a form was received.'
  setUserLED true
  '[io:playTone]' -1 440
  waitMillis 200
  setUserLED false
  '[io:playTone]' -1 0
  if (('[data:find]' '?R=' path) != -1) {
    rgbFormRequest path
  }
  comment 'Could add cases to handle additional
forms here...'
  '[net:respondToHttpRequest]' '200 OK' 'Form received.'
}

to homePageRequest {
  local 'homePageHTML' '<!DOCTYPE html>
<html>
<body><h1>NeoPanel Color Settings</h1>
<form action="">
<label for="red">RED (0-255):</label>
<input  style="accent-color: red" type="range" name="R" min="0" max="255"></br>
<label for="green">GREEN (0-255):</label>
<input  style="accent-color: green" type="range" name="G" min="0" max="255"></br>
<label for="blue">BLUE (0-255):</label>
<input  style="accent-color: blue" type="range" name="B" min="0" max="255"></br>
<label for="X">X (1-16):</label>
<input type="number" name="X" min="1" max="16" value="1"></br>
<label for="Y">Y (1-16):</label>
<input type="number" name="Y" min="1" max="16" value="1"></br></br>
<input style="font-size: x-large;" type="submit">
</form></body></html>'
  '[net:respondToHttpRequest]' '200 OK' homePageHTML
}

to rgbFormRequest path {
  comment 'Expected path format:
?R=255&G=255&B=255'
  local 'i' ('[data:find]' '?R=' path)
  path = ('[data:copyFromTo]' path (i + 1))
  local 'colors' ('[data:split]' path '&')
  if ((size colors) < 3) {
    return 0
  }
  local 'r' (0 + ('[data:copyFromTo]' (at 1 colors) 3))
  local 'g' (0 + ('[data:copyFromTo]' (at 2 colors) 3))
  local 'b' (0 + ('[data:copyFromTo]' (at 3 colors) 3))
  local 'x' (0 + ('[data:copyFromTo]' (at 4 colors) 3))
  local 'y' (0 + ('[data:copyFromTo]' (at 5 colors) 3))
  waitMillis 10
  neoPanel_drawPixel x y (colorFromRGB r g b)
}

script 40 40 {
whenStarted
neoPanel_attach 16 16 12
NeoPixel_brighten_all -70
comment 'Fill in your network name (SSID) and password here:'
wifiConnect 'Network_Name' ''
forever {
  local 'request' ('[net:httpServerGetRequest]')
  if (request != '') {
    local 'path' ('path of request' request)
    comment 'Handle the request based on the URL path'
    if ('/' == path) {
      homePageRequest
    } ('/favicon.ico' == path) {
      favIconRequest
    } (('[data:find]' '?' request) > 0) {
      formRequest path
    } ('/clear' == path) {
      clearNeoPixels
      '[net:respondToHttpRequest]' '200' 'ok'
    } else {
      '[net:respondToHttpRequest]' '404 Not found'
    }
  }
  waitMillis 10
}
}

script 434 60 {
comment 'This example shows how to create a browser remote control panel
on a WIFi-capable board that allows the board to be controlled from
a web browser on any phone, tablet, or laptop.

It works by creating a simple HTTP server that both serves the
control panel as an HTML form and also responds to requests
generated by that form.

In this example, the form contains sliders for red, green, and blue.
Submitting the form sends an HTTP request containing the slider
values encoded in a URL like this:

 /?R=100&G=0&B=25&X=1&Y=2

The server responds to such requests by:

  1. blinking the user LED
  2. making a beep sound (if the board has a speaker)
  3. setting the NeoPanel pixel to the given color (if the board has Neopixels)

It also responds to browser requests for favicon.ico.

One final feature: if the request URL is not "/", "favicon.ico" or a URL
containing a question mark, it is taken to be a file name, and the server
will return the contens of a file of that name in the boad''s file system.

Of course, this is just a starting point. You can modify this example to
create all sorts of browser-controlled projects.
  
Enjoy!
'
}


module BMP Output
author 'José García Yeste'
version 1 9 
depends TFT Files 
description 'Display BMP files on a TFT screen.

BMP files can be transferred to and from boards with a file systems using the put/get commands in the IDE file menu (available in "show advanced blocks" mode).
Dragging a BMP file over microBlocks also loads the file into the file system.

This library works with uncompressed BMP files with 1, 4, 8, 16, 24 and 32 bits per pixel.
'
variables _bmpPalette _bmpIsRGB565 _bmpPixelsOffset _bmpWidth _bmpHeight _bmpBPP 

  spec ' ' 'drawBMPfile' 'display BMP file _ at x _ y _' 'str num num' 'image.bmp' 0 0
  space
  spec 'r' '_bmp_readHeader' '_bmp_readHeader file _' 'str' ''
  spec ' ' '_bmp_drawBMP' '_bmp_drawBMP file _ x _ y _' 'str num num' '' 0 0
  spec ' ' '_bmp_drawBMPPixels' '_bmp_drawBMPPixels file _ x _ y _ with function _' 'str num num str' '' 0 0 '[tft:setPixel]'
  space
  spec 'r' '_bmp_readPixelLine' '_bmp_readPixelLine of file _' 'str' ''
  spec ' ' '_bmp_addOneBytePixelsTo' '_bmp_addBytePixels from _ starting at _ to _' 'str num str' '' 1 'aList'
  spec 'r' '_bmp_16BitPixel' '_bmp_16BitPixel from _ starting at _' 'str num' '' 1
  spec 'r' '_bmp_24BitPixel' '_bmp_24BitPixel from _ starting at _' 'str num' '' 1
  space
  spec 'r' '_bmp_readInt16' '_bmp read int16 file _' 'str' ''
  spec 'r' '_bmp_readInt32' '_bmp read int32 file _' 'str' ''
  space
  spec ' ' '_bmp_skip' '_bmp skip _ bytes of file _' 'num str' 0 ''

to '_bmp_16BitPixel' data i {
  local 'pixel' (((at (i + 1) data) << 8) | (at i data))
  if _bmpIsRGB565 {
    local 'r' ((pixel >> 8) & 248)
    local 'g' ((pixel >> 3) & 248)
    local 'b' ((pixel & 31) << 3)
  } else {
    local 'r' ((pixel >> 7) & 248)
    local 'g' ((pixel >> 2) & 248)
    local 'b' ((pixel & 31) << 3)
  }
  return ((r << 16) | ((g << 8) | b))
}

to '_bmp_24BitPixel' data i {
  return ((((at (i + 2) data) << 16) | ((at (i + 1) data) << 8)) | (at i data))
}

to '_bmp_addOneBytePixelsTo' data i buf {
  local 'mask' ((1 << _bmpBPP) - 1)
  local 'pixels' (at i data)
  local 'b' (8 / _bmpBPP)
  repeatUntil (b < 1) {
    b += -1
    '[data:addLast]' (at (((pixels >> (_bmpBPP * b)) & mask) + 1) _bmpPalette) buf
  }
}

to '_bmp_drawBMP' filename originX originY {
  '[file:open]' filename
  '_bmp_skip' _bmpPixelsOffset filename
  if (_bmpHeight >= 0) {
    local 'y' ((originY + _bmpHeight) - 1)
  } else {
    local 'y' originY
  }
  local 'optimize' ((boardType) != 'Boardie')
  repeat (absoluteValue _bmpHeight) {
    local 'line' ('_bmp_readPixelLine' filename)
    if optimize {
      local 'rep' 1
      local 'lastColor' (at 1 line)
      for x (size line) {
        if ((at x line) != lastColor) {
          if (rep > 1) {
            '[tft:line]' (((x - 1) - rep) + originX) y ((x - 0) + originX) y lastColor
          } else {
            '[tft:setPixel]' ((x - 1) + originX) y lastColor
          }
          lastColor = (at x line)
          rep = 1
        } else {
          rep += 1
        }
      }
      '[tft:line]' ((x - rep) + originX) y (x + originX) y lastColor
    } else {
      for x (size line) {
        '[tft:setPixel]' ((x - 1) + originX) y (at x line)
      }
    }
    if (_bmpHeight >= 0) {
      y += -1
    } else {
      y += 1
    }
  }
}

to '_bmp_drawBMPPixels' filename originX originY setPixelFunction {
  comment 'Much slower than _bmp_drawBMP but allows client to supply
a setPixelFunction, so it can be used to draw a BMP file
file onto other devices such as a NeoPixel panel.'
  '[file:open]' filename
  '_bmp_skip' _bmpPixelsOffset filename
  if (_bmpHeight >= 0) {
    local 'y' ((originY + _bmpHeight) - 1)
    local 'yIncrement' -1
  } else {
    local 'y' originY
    local 'yIncrement' 1
  }
  local 'parameters' (newList 3)
  repeat (absoluteValue _bmpHeight) {
    local 'line' ('_bmp_readPixelLine' filename)
    for x (size line) {
      atPut parameters 1 (originX + (x - 1))
      atPut parameters 2 y
      atPut parameters 3 (at x line)
      callCustomCommand setPixelFunction parameters
    }
    y += yIncrement
  }
}

to '_bmp_readHeader' filename {
  '[file:open]' filename
  if (or (('[file:fileSize]' filename) < 54) ('BM' != ('[data:join]' '' ('[file:readBytes]' 2 filename)))) {
    printIt ('[data:join]' 'Not a BMP file: ' filename)
    sayIt 'Not a BMP file: ' filename
    return false
  }
  '_bmp_skip' 8 filename
  _bmpPixelsOffset = ('_bmp_readInt32' filename)
  '_bmp_skip' 4 filename
  _bmpWidth = ('_bmp_readInt32' filename)
  _bmpHeight = ('_bmp_readInt32' filename)
  '_bmp_skip' 2 filename
  _bmpBPP = ('_bmp_readInt16' filename)
  local 'compression' ('_bmp_readInt32' filename)
  _bmpIsRGB565 = false
  '_bmp_skip' 20 filename
  if (compression == 3) {
    _bmpIsRGB565 = true
    '_bmp_skip' 12 filename
  } (compression != 0) {
    sayIt 'Compressed BMP files are not supported'
    return false
  }
  _bmpPalette = 0
  if (_bmpBPP <= 8) {
    comment 'Read color palette'
    _bmpPalette = (newList (1 << _bmpBPP))
    for i (size _bmpPalette) {
      local 'data' ('[file:readBytes]' 4 filename)
      local 'color' (((at 3 data) << 16) | (((at 2 data) << 8) | (at 1 data)))
      atPut i _bmpPalette color
    }
  }
  return true
}

to '_bmp_readInt16' filename {
  local 'data' ('[file:readBytes]' 2 filename)
  return (((at 2 data) << 8) | (at 1 data))
}

to '_bmp_readInt32' filename {
  local 'data' ('[file:readBytes]' 4 filename)
  return ((((at 4 data) << 24) | ((at 3 data) << 16)) | (((at 2 data) << 8) | (at 1 data)))
}

to '_bmp_readPixelLine' filename {
  local 'result' ('[data:makeList]')
  local 'bytes' (((_bmpWidth * _bmpBPP) + 7) / 8)
  local 'data' ('[data:newByteArray]' bytes)
  bytes = ('[file:readInto]' data filename)
  i = 1
  repeatUntil (i > bytes) {
    if (_bmpBPP <= 8) {
      '_bmp_addOneBytePixelsTo' data i result
    } (_bmpBPP == 16) {
      '[data:addLast]' ('_bmp_16BitPixel' data i) result
    } else {
      '[data:addLast]' ('_bmp_24BitPixel' data i) result
    }
    i += (maximum (_bmpBPP / 8) 1)
  }
  if (((size data) % 4) != 0) {
    '_bmp_skip' (4 - ((size data) % 4)) filename
  }
  return result
}

to '_bmp_skip' bytes filename {
  return ('[file:readInto]' ('[data:newByteArray]' bytes) filename)
}

to drawBMPfile filename originX originY {
  if ('_bmp_readHeader' filename) {'_bmp_drawBMP' filename originX originY}
  '[file:close]' filename
}


module Files Data
author MicroBlocks
version 1 3 
description 'Flash file system operations. Currently supports the LittleFS file system on ESP8266 and ESP32 boards. The GnuBlocks virtual machine (Linux and Raspberry Pi) supports the native system.'

  spec ' ' '[file:open]' 'open file _' 'str'
  spec ' ' '[file:close]' 'close file _' 'str'
  spec ' ' '[file:delete]' 'delete file _' 'str'
  space
  spec ' ' '[file:appendLine]' 'append line _ to file _' 'str str'
  spec ' ' '[file:appendBytes]' 'append bytes _ to file _' 'str str'
  space
  spec 'r' '[file:endOfFile]' 'end of file _' 'str'
  spec 'r' '[file:readLine]' 'next line of file _' 'str'
  spec 'r' '[file:readBytes]' 'next _ bytes of file _ : starting at _' 'num str num' 100 '' 0
  spec 'r' '[file:readInto]' 'read into _ from file _' 'str str' 'a ByteArray' ''
  space
  spec 'r' '[file:readPosition]' 'read position of file _' 'str'
  spec ' ' '[file:setReadPosition]' 'set read position _ of file _' 'num str' 0 ''
  spec ' ' 'file_SkipBytes' 'skip _ bytes of file _' 'num str' 4 ''
  space
  spec 'r' 'file names' 'file names : in directory _' 'str'
  spec 'r' '[file:fileSize]' 'size of file _' 'str'
  spec 'r' '[file:systemInfo]' 'file system info'

to 'file names' dir {
  '[file:startList]' dir
  local 'result' ('[data:makeList]')
  local 'fileName' ('[file:nextInList]')
  repeatUntil (fileName == '') {
    '[data:addLast]' fileName result
    fileName = ('[file:nextInList]')
  }
  return result
}

to file_SkipBytes offset file {
  local 'newPosition' (('[file:readPosition]' file) + offset)
  '[file:setReadPosition]' newPosition file
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _' 'bool' false
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module NeoPanel Output
author 'José García Yeste & Víctor Casado'
version 1 0 
depends BMP NeoPixel 
description 'Draw lines, rectangles, text, and images on a NeoPixel panels (e.g. 8x8, 16x16 or 32x8) in either horizontal or vertical orientation. Panels can be daisy-chained to create larger displays if there is sufficient power to drive them.
See: https://www.btf-lighting.com/collections/led-matrix-display/products/ws2812b-panel-screen-8-8-16-16-8-32-pixel-256-pixels-digital-flexible-led-programmed-individually-addressable-full-color-dc5v#
'
variables _neoPanel_width _neoPanel_height _neoPanel_isHorizontal 

  spec ' ' 'neoPanel_attach' 'attach NeoPixel panel width _ height _ at pin _' 'num num num' 8 8 1
  space
  spec ' ' 'neoPanel_drawPixel' 'NeoPanel set x _ y _ color _' 'num num color' 1 1
  spec ' ' 'neoPanel_drawVerticalLine' 'NeoPanel fill column _ color _' 'num color' 1
  spec ' ' 'neoPanel_drawHorizontalLine' 'NeoPanel fill row _ color _' 'num color' 1
  spec ' ' 'neoPanel_fillRectangle' 'NeoPanel fill rectangle x _ y _ width _ height _ color _' 'num num num num color' 1 1 4 4
  space
  spec ' ' 'neoPanel_drawText' 'NeoPanel draw text _ at x _ y _ color _' 'str num num color' 'HELLO' 1 1
  spec ' ' 'neoPanel_drawBMP' 'NeoPanel draw BMP file _ at x _ y _' 'str num num' '' 1 1
  space
  spec 'r' '_neoPanel_indexForXY' '_neoPanel_index for x _ y _' 'num num' 1 1

to '_neoPanel_indexForXY' x y {
  if (or (x < 1) (y < 1)) {return 0}
  if (or (x > _neoPanel_width) (y > _neoPanel_height)) {return 0}
  if _neoPanel_isHorizontal {
    if ((x & 1) == 0) {
      return (((x - 1) * _neoPanel_height) + ((_neoPanel_height - y) + 1))
    } else {
      return (((x - 1) * _neoPanel_height) + y)
    }
  } else {
    if ((y & 1) == 0) {
      return (((y - 1) * _neoPanel_width) + x)
    } else {
      return (((y - 1) * _neoPanel_width) + ((_neoPanel_width - x) + 1))
    }
  }
}

to neoPanel_attach width height pin {
  _neoPanel_width = width
  _neoPanel_height = height
  _neoPanel_isHorizontal = (width >= height)
  neoPixelAttach (_neoPanel_width * _neoPanel_height) pin
}

to neoPanel_drawBMP filename x0 y0 {
  if (not ('_bmp_readHeader' filename)) {return}
  '[file:open]' filename
  '_bmp_skip' _bmpPixelsOffset filename
  if (_bmpHeight >= 0) {
    local 'y' ((originY + _bmpHeight) - 1)
    local 'yIncrement' -1
  } else {
    local 'y' originY
    local 'yIncrement' 1
  }
  repeat _bmpHeight {
    local 'line' ('_bmp_readPixelLine' filename)
    for x (size line) {
      local 'pixel' ('_neoPanel_indexForXY' ((x0 - 1) + x) (y0 + y))
      if (pixel > 0) {
        atPut pixel _np_pixels (at x line)
      }
    }
    y += yIncrement
  }
  '[file:close]' filename
  '_NeoPixel_update'
}

to neoPanel_drawHorizontalLine y color {
  if (and (y > 0) (y <= _neoPanel_width)) {
    if _neoPanel_isHorizontal {
      local 'index' (((y - 1) * _neoPanel_height) + 1)
      repeat _neoPanel_height {
        atPut index _np_pixels color
        index += 1
      }
    } else {
      local 'index' ((_neoPanel_width - y) + 1)
      repeat (_neoPanel_height / 2) {
        atPut index _np_pixels color
        index += (((y - 1) * 2) + 1)
        atPut index _np_pixels color
        index += ((((_neoPanel_width - y) + 1) * 2) - 1)
      }
    }
    '_NeoPixel_update'
  }
}

to neoPanel_drawPixel x y color {
  setNeoPixelColor ('_neoPanel_indexForXY' x y) color
}

to neoPanel_drawText text x0 y0 color {
  for letter text {
    local 'shape' ('[display:mbShapeForLetter]' letter)
    local 'mask' 1
    local 'x' (x0 - 1)
    local 'y' (y0 - 1)
    for c 5 {
      for f 5 {
        if ((shape & mask) != 0) {
          local 'i' ('_neoPanel_indexForXY' (x + f) (y + c))
          if (i > 0) {
            atPut i _np_pixels color
          }
        }
        mask = (mask << 1)
      }
    }
    if _neoPanel_isHorizontal {
      x0 += 5
    } else {
      y0 += 6
    }
  }
  '_NeoPixel_update'
}

to neoPanel_drawVerticalLine x color {
  if (and (x > 0) (x <= _neoPanel_height)) {
    if _neoPanel_isHorizontal {
      local 'index' x
      repeat (_neoPanel_width / 2) {
        atPut index _np_pixels color
        index += (((_neoPanel_height - x) * 2) + 1)
        atPut index _np_pixels color
        index += ((x * 2) - 1)
      }
    } else {
      local 'index' (((x - 1) * _neoPanel_width) + 1)
      atPut index _np_pixels color
      repeat _neoPanel_width {
        atPut index _np_pixels color
        index += 1
      }
    }
    '_NeoPixel_update'
  }
}

to neoPanel_fillRectangle x y width height color {
  local 'column' y
  repeat height {
    local 'row' x
    repeat width {
      atPut ('_neoPanel_indexForXY' row column) _np_pixels color
      row += 1
    }
    column += 1
  }
  '_NeoPixel_update'
}


module NeoPixel Output
author MicroBlocks
version 1 5 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}


module WiFi Comm
author MicroBlocks
version 1 5 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 10000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

